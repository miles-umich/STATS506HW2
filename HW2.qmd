---
title: "HW2"
author: "Margaret Miles"
format: html
editor: visual
---

## STATS 506 - HW2

Margaret Miles

## **Problem 1 - Modified Random Walk**

Consider a 1-dimensional random walk with the following rules:

Start at 0. At each step, move +1 or -1 with 50/50 probability. If +1 is chosen, 5% of the time move +10 instead. If -1 is chosen, 20% of the time move -3 instead. Repeat steps 2-4 times. (Note that if the +10 is chosen, it’s not +1 then +10, it is just +10.)

Write a function to determine the end position of this random walk.

The input and output should be:

Input: The number of steps

Output: The final position of the walk

random_walk(10) \[1\] 4

random_walk(10) \[1\] -11

We’re going to implement this in different ways and compare them.

**a. Implement the random walk in these three versions:**

Version 1: using a loop.

```{r}

#' Version 1 of random walk
#'
#' Takes a random step number count based on input starting at 0, and returns a random output
#' 
#' @params n = number of steps in the walk
#' @returns final = final position of the walk
#' 
#' @examples
#' ver1(10) = 4
#' ver1(10) = -11
#' 
ver1 <- function(n){
  # start at 0
  walk <- 0
  steps <- 1
  # At each step from 1 to n input  
  for (steps in 1:n){
    # move +1 or -1 with 50/50 probability
    move <- sample(c(1,-1), size = 1, prob = c(0.5, 0.5))
    # take a step in that direction
    # print(move)
    walk <- walk + move
    # +1 is chosen, 5% of the time move +10 instead (9 because you already stepped 1)
    if (move > 0) {
      walk <- walk + sample(c(0, 9), 1, prob = c(0.95, 0.05))
      # print(walk)
    } else {
      # If -1 is chosen, 20% of the time move -3 instead. (-2 because you already stepped -1)
      walk <- walk + sample(c(0, -2), 1, prob = c(0.80, 0.20))
      # print(walk)
    }
  }
  final <- walk
  return(final)
}

ver1(10)
ver1(10)
```

Version 2: using built-in R vectorized functions. (Using no loops.) (Hint: Does the order of steps matter?)

```{r}
#' Version 2 of random walk
#'
#' Takes a random step number count based on input starting at 0, and returns a random output
#' using vectorized functions
#' 
#' @params n = number of steps in the walk
#' @returns final = final position of the walk
#' 
#' @examples
#' ver1(10) = 4
#' ver1(10) = -11
#' 
ver2 <- function(n){
  # set up moves +1 or -1
  steps <- sample(c(1, -1), n, replace = TRUE)
  # print(steps)
  
  # +10 jump 5% of the time when base is +1
  steps[steps == 1] <- 1 + rbinom(sum(steps == 1), 1, 0.05) * 9
  # print(steps)
  
  # -3 jump 20% of the time
  steps[steps == -1] <- -1 +rbinom(sum(steps == -1), 1, 0.20) * -2
  # print(steps)
  
  # then sum to find final spot
  final <- sum(steps)
  return(final)
}

ver2(10)
ver2(10)
```

Version 3: Implement the random walk using one of the “apply” functions.

```{r}
#' Version 3 of random walk
#'
#' Takes a random step number count based on input starting at 0, and returns a random output
#' using apply functions
#' 
#' @params n = number of steps in the walk
#' @returns final = final position of the walk
#' 
#' @examples
#' ver1(10) = 4
#' ver1(10) = -11
#' 
ver3 <- function(n){
  # set up moves +1 or -1
  steps <- sample(c(1, -1), n, replace = TRUE)
  
  # using apply function, +10 jump 5% of the time when base is +1
  # and -3 jump 20% of the time when base is -1
  walk <- vapply(steps, function(x){
    if(x == 1){
      x <- sample(c(1, 10), 1, prob = c(0.95, 0.05))
    } else {
      x <- sample(c(-1, -3), 1, prob = c(0.80, 0.20))
    }
  }, numeric(1))
  # print(walk)
  return(sum(walk))
}

ver3(10)
ver3(10)
```

Demonstrate that all versions work by running the following: random_walk1(10) random_walk2(10) random_walk3(10) random_walk1(1000) random_walk2(1000) random_walk3(1000)

```{r}
random_walk1 <- ver1
random_walk2 <- ver2
random_walk3 <- ver3

random_walk1(10) 
random_walk2(10) 
random_walk3(10) 
random_walk1(1000) 
random_walk2(1000) 
random_walk3(1000)

```

**b. Demonstrate that the three versions can give the same result. Show this for both n=10 and n=1000. (You will need to add a way to control the randomization.)**

```{r}

# version #1 walk for same result
random_walk1_same <- function(n) {
  
  # set up with +1 or -1
  steps <- sample(c(1, -1), n, replace = TRUE)
  
  # check to see if start is the same
  # print(steps)
  
  # At each step from 0 to n input  
  for (i in 1:n){
    # +1 is chosen, 5% of the time move +10 
    if (steps[i] > 0) {
      steps[i] <- sample(c(1, 10), 1, prob = c(0.95, 0.05))
    } else {
      # If -1 is chosen, 20% of the time move -3 
      steps[i] <- sample(c(-1, -3), 1, prob = c(0.80, 0.20))
    }
  }
  # print(steps)
  
  # sum
  final <- sum(steps)
  return(final)
}

# version #2 walk for same result
random_walk2_same <- function(n) {
  
  # set up with +1 or -1
  steps <- sample(c(1, -1), n, replace = TRUE)
  
  # check to see if start is the same
  # print(steps)
  
  # find how many of each there are
  size1 <- sum(steps == 1)
  size2 <- sum(steps == -1)

  # +10 jump 5% of the time when base is +1
  steps[steps == 1] <- sample(c(1, 10), size = size1, replace = TRUE, 
                              prob = c(0.95, 0.05))
  # print(steps)
  
  # -3 jump 20% of the time when base is -1
  steps[steps == -1] <- sample(c(-1, -3), size = size2, replace = TRUE,
                               prob = c(0.80, 0.20))
  # print(steps)

  # then sum to find final spot
  final <- sum(steps)
  return(final)
}
# version #2 walk for same result
random_walk2_same <- function(n) {
  
  # set up with +1 or -1
  steps <- sample(c(1, -1), n, replace = TRUE)
  
  # check to see if start is the same
  # print(steps)
  
  # find how many of each there are
  size1 <- sum(steps == 1)
  size2 <- sum(steps == -1)

  # +10 jump 5% of the time when base is +1
  steps[steps == 1] <- sample(c(1, 10), size = size1, replace = TRUE, 
                              prob = c(0.95, 0.05))
  # print(steps)
  # -3 jump 20% of the time when base is -1
  steps[steps == -1] <- sample(c(-1, -3), size = size2, replace = TRUE,
                               prob = c(0.80, 0.20))
  # print(steps)

  # then sum to find final spot
  final <- sum(steps)
  return(final)
}

set.seed(67)
random_walk1_same(10)
set.seed(67)
random_walk2_same(10)



```
